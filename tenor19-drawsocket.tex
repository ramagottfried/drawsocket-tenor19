% load TENOR file template
\input{tenor19-packages}

% paper title, authors
\def\papertitle{drawsocket: A browser based system for networked score display%:  and the St. Pauli Elbtunnel project
}
\def\firstauthor{Rama Gottfried}
\def\secondauthor{Jacob Sello}
\def\thirdauthor{Georg Hajdu}

\def\Hochschule{ Hochschule f\"ur Musik und Theater}

\title{\papertitle}
 \threeauthors
   {\firstauthor} {	
      Hochschule f\"ur Musik und Theater\\
         Hamburg, Germany \\ %
   \small{\tt \href{mailto:rama.gottfried@hfmt-hamburg.de}{rama.gottfried@hfmt-hamburg.de}}}
    {\secondauthor} {
   Hochschule f\"ur Musik und Theater\\
   Hamburg, Germany \\ %
   \small{\tt \href{mailto:jacob.sello@hfmt-hamburg.de}{jacob.sello@hfmt-hamburg.de}}}
   {\thirdauthor} {
   Hochschule f\"ur Musik und Theater\\
   Hamburg, Germany \\ %
   \small{\tt \href{mailto:georg.hajdu@hfmt-hamburg.de}{georg.hajdu@hfmt-hamburg.de}}}

% other setup
\input{tenor19-setup}

% ------ Start of Document -----

\begin{document}
%

\capstartfalse
\maketitle
\capstarttrue
%
\begin{abstract}
We present \drawsocket, a new platform for generating synchronized, browser-based displays across an array of networked devices developed at the \Hochschule, Hamburg. Conceived as a system for distributed notation display with applications in music and spatial performance contexts, \drawsocket provides a unified interface for controlling diverse functions running in client browsers. 
In addition, \drawsocket provides tools which allow the system to be extended for realtime user interaction.
Included is a discussion of the architecture design and development process, followed by an overview of the features, and syntax considerations for the \drawsocket API.

\end{abstract}

\input{intro-foundations.tex}

\section{drawsocket}\label{sec:drawsocket}
The \drawsocket design approach is based on the ``o.io'' paradigm developed at the University of California, Berkeley's Center for New Music and Technology (CNMAT), which uses the OpenSoundControl (OSC) encoding~\cite{wright:osc} to create a uniform user application programing interface (API) by ``wrapping'' vendor- and protocol- specific details in an interoperable API syntax~\cite{freed2014io, maccallum2015dynamic}.
In this way, the \drawsocket system aims to be an ``o.io'' wrapper for web-browser display and interaction, providing an OSC API for manipulating the display building blocks of Scalable Vector Graphics (SVG)\footnote{https://www.w3.org/TR/SVG11/}, Cascading Style Sheets (CSS)\footnote{https://www.w3.org/Style/CSS/specs.en.html}, HyperText Markup Language (HTML)~\footnote{https://www.w3.org/TR/html52/}, and a curated collection of client-based JavaScript libraries for animation and sound production.

\begin{figure*}[]
\centering
\includegraphics[width=\textwidth]{drawsocket-system.png}
\caption{\drawsocket Sever/Client Architecture. 
\label{fig:drawsocket-arch}}
\end{figure*}

\subsection{Architecture Overview}
The \drawsocket architecture is structured as a server-client system, using Max\footnote{https://cycling74.com}  as the primary controller interface, to send drawing messages via a Node.js\footnote{https://nodejs.org} server, with then routes control messages to the client web-browser, which parses the messages, and uses the data to generate content in the client browser. 

The choice of Node.js was particularly helpful due to the Node Package Manager (NPM), which is bundled with Node.js, allowing \drawsocket to leverage the active community of Javascript library development of tools for browser-based display and inter-computer communication \cite{trockman2018adding}. 
Further, NPM also provides a practical method for managing libraries dependancies, via the \textit{package.json} system.

In an effort to scale to larger groups of clients running off of the same server, a loosely defined \textit{model-view-controller} \cite{krasner1988description} pattern is used to separate the processes. 
The server is used primarily to relay and cache the drawing commands, while the drawing implementation is offloaded to the client browsers, which with recent developments in mobile computing have become quite efficient~\cite{halpern2016mobile}.
See figure~\ref{fig:drawsocket-arch} for an overview schematic of the system. 

\subsection{Controller}
\noindent
\textbf{Max.}
Currently the primary targeted user server control platform is Max, which is provides many algorithmic and interprocess communications tools. 
Since the release of Max 8, Max now includes the NodeForMax (N4M)\footnote{https://docs.cycling74.com/nodeformax/api/} framework, which embeds the Node.js server engine within the Max programming environment, accessible through a set of Max objects.

The first versions of the \drawsocket system used an independent Node.js application running from the command prompt and a User Datagram Protocol (UDP)\footnote{https://tools.ietf.org/html/rfc768} socket to send and receive OSC bundles to and from Max, which were then broadcast to subscribed clients.
However, after comparing benchmarks measuring the roundtrip messaging time between Max and node.js, the N4M system was found to be faster, and so we adopted this platform as the primary use case.
\drawsocket system is well compartmentalized, and so could still easily be reconfigured to use UDP input for use with other control software.

Within Max, the core Node.js server script, \textit{drawsocket-server.js}, is run within Max's \textit{node.script} object. 
For convenience, the node.script object is wrapped in Max abstraction called \textit{hfmt.drawsocket} which aids in API syntax formatting, managing server asset paths, and handles user interaction messages returning from the client (see section~\ref{sec:setup} for more details).

\medskip
\noindent
\textbf{OSC-JSON representation.}
The \drawsocket data is formatted as a key-value tree, which in Max can be represented as either OSC, or in Max Dictionary format,
both of which can easily transformed to JavaScript Object Notation (JSON)\footnote{https://www.json.org/}. See section~\ref{sec:api} below for an in-depth description of the \drawsocket messaging syntax.

\subsection{Server}
\noindent
\textbf{Node.js.}
The Node.js server consists of four main processes: (1) an Express HTTP server\footnote{https://expressjs.com/}, (2) a WebSocket\footnote{https://www.npmjs.com/package/ws} connection manager, (3) state caching, and (4) handling messages from the client (either forwarding them to the Max host environment or responding back to client,  as in the case of clock synchronization and on-load initialization).

\medskip
\noindent
\textbf{Express.}
The Express JS library is used to create the web-sever and handle HyperText Transfer Protocol (HTTP)\footnote{https://www.w3.org/Protocols/} requests from client browsers. 
By default, the server responds to all page requests with a set of default HTML files which contain the basic setup necessary for most uses of the \drawsocket system, and links to dependency JS libraries, fonts, and a default CSS stylesheet.

From the Max interface, uses can send the \textit{html\_template} message set a different default HTML page if desired.

The Express server uses a static public root folder, which exposes a selected folder path that client browsers may load files from. 
To set the root public folder, users can set the \textit{html\_root} folder path as an initialization argument to the \textit{hfmt.drawsocket} abstraction.

User configuration of the system is described further in section~\ref{sec:setup}.

\medskip
\noindent
\textbf{WebSockets.}
WebSockets are used as the primary server-client communication exchange protocol.
The server accepts WebSocket requests from client browsers with a valid OSC prefix URL.

Control messages composed in Max, are received in JSON format by the server, and routed the messages to the client identified by a corresponding ``OSC address prefix'', defined by the client browser's URL address.

\medskip
\noindent
\textbf{OSC prefix state caching.}
On connection to a new OSC prefix, the sever adds the prefix to its list of known client prefixes, and begins logging the prefix state in the server's state caching system. 
Every control command received and routed to a known client OSC prefix, is then timestamped, and stored in an internal state storage object array.

Users may pre-initialize a set of OSC prefixes that will be tracked by the state caching system, using the \textit{addprefix} message from Max.
This provides a mechanism for preloading a set of drawing commands to a OSC prefix, so that when a user first loads the page, or hits refresh, the current drawing state of the page will be loaded.

\medskip
\noindent
\textbf{Client return messages.}
WebSocket connection is bidirectional, and is used to handle messages from the client: responding to clock synchronization requests, client requests for initialization, and forwarding user interaction information to Max.

\medskip
\noindent
\textbf{Connection Port.} 
On startup, the server provides it's IP address and connection port to the Max environment.
Clients may connect remotely via network IP address, or if on the same computer, use the localhost identifier, followed by the port number (currently 3002 by default), separated by a colon (e.g. \textit{http://localhost:3002}).
 
 \subsection{Client}  
Running inside a web-browser, the client-side component of the \drawsocket system handles the drawing and sound generating commands, clock synchronization, and user interface event watchers.

\medskip
\noindent
\textbf{Web-browser.}  
Currently the system targets Safari and Chrome. 
Firefox support is currently out of sync with the other browsers, but will be supported. Other browsers will most likely work, but are not currently being tested.

\medskip
\noindent
\textbf{Layout.}
The central browser display layout consists of one HTML \textless div\textgreater\ node, which contains an \textless svg\textgreater\ element, and an SVG \textless g\textgreater\ group node. 

\begin{lstlisting}[
  mathescape,
  columns=fullflexible,
  basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
 <div id=``main-div''>
    <svg>
         <defs id=``defs''></defs>
         <g id=``main-svg''></g>
    </svg>
 </div>
\end{lstlisting}

The default formatting for the basic page elements is setup in the \textit{drawsocket-defaults.css}.
When users add SVG elements, they are added to the ``main-svg'' group.
Users may also create new SVG groups and add elements to these new groups, to control stacking order, described below in more detail.

\medskip
\noindent
\textbf{Libraries.}
\drawsocket currently makes use of the following client-side Javascript libraries, all available from NPM:

{D3.js},\footnote{https://d3js.org/} a library for SVG information visualization.\footnote{We are now mainly using d3.js for DOM node creation and manipulation. So, eventually it is likely that we will remove the d3.js dependency to streamline the codebase. However for the time being d3's utility functions are convenient for rapid development, and appear to be performant enough.}

{PDF.js},\footnote{https://mozilla.github.io/pdf.js/} a PDF viewer library developed by Mozilla, providing support for PDF file reading, viewing and page turning.

{Tone.js},\footnote{https://tonejs.github.io} a web-audio library by Yotam Mann. Currently, \drawsocket uses Tone.js to provide basic soundfile playback functionality, this may be expanded in the future.

{Timesync.js},\footnote{https://www.npmjs.com/package/timesync} a clock synchronization library, used in \drawsocket to synchronize animations, and provide a mechanism for timed commands.

 {TweenMax} and {TimelineMax}, from the GreenSock Animation Platform (GSAP),\footnote{https://greensock.com/gsap} a high-performance system for JS and CSS animation.
%
%\begin{figure*}[]
%\centering
%\includegraphics[width=0.75\textwidth]{display-layers.png}
%\caption{\drawsocket display layers. 
%\label{fig:drawsocket-layers}}
%\end{figure*}
%

\medskip
\noindent
\textbf{Client-side Script.} 
The main the client-side script is called \textit{drawsocket-client.js} and handles the main drawing and command processing logic of the system.

On load, the script first requests a new WebSocket connection to the server, using the browser's URL as the OSC prefix as the WebSocket identifier. On successful WebSocket connection, the script begins the clock synchronization process which runs in the background on the client system, requesting new clock readings from the server at regular intervals\footnote{Currently, the script is configured to check every 5 seconds, but this may change depending on performance on a larger scale system}. Once the initial clock synchronization is completed, the script sends an state initialization request to the server, to which the server responds with a sequence of commands corresponding to the current state of the given OSC prefix.

The central command processing is performed in the \textit{processCmdObj} function, which parses an array of time-tagged command objects, and executes the corresponding graphic and sound manipulations in the browser. The \textit{processCmdObj} function expects one or more objects with a \textit{key}, \textit{val}, and \textit{timetag} key-value pairs:

\begin{lstlisting}[
  mathescape,
  columns=fullflexible,
  basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  {
      timetag: current time (supplied by server),
      key: command string
      val: command arguments
  }
\end{lstlisting}
\noindent
Generally, these objects are formatted in the Node.js server from the API command messages received via Max, however they may also be created by user scripts called from event watchers.

%%%%%%%% User Setup
\section{Drawsocket User Setup}\label{sec:setup}
The interface for \drawsocket is designed for use in the context Max, and is distributed as a Max Package called ``hfmt.drawsocket'', currently hosted on GitHub at the following url:

\textit{https://github.com/ramagottfried/hfmt-drawsocket}

To install, users download the hfmt.drawsocket repository and place it in Max's Packages folder. Once installed, users can instantiate the \drawsocket system by placing the hfmt.drawsocket object in a Max patch.

The dependency NPM libraries are not distributed with the package, so on first loading hfmt.drawsocket, you must first send the object the \textit{script NPM install} message, which asks NPM to download all of the dependencies listed in the node project's \textit{packages.json} file.\footnote{The node project is located in the package's /code/node folder, and includes all scripts, and configuration files.}

\medskip
\noindent
\textbf{Setting the public folder.}  As mentioned above, by default the \drawsocket server responds to HTTP URL page requests with a default HTML page. 
Custom HTML pages, and/or other types of assets can also be served to the client from a static root public folder. 

The public root folder is a method commonly used to control client access to server folders, and can be set in Max by supplying the relative path to the user's Max patch\footnote{Note that the Max patch must be saved to disk before it will have a valid folder path.} as an argument to the hfmt.drawsocket object.
This system allows users to organize their project in a mobile way, easily moved or installed on a new system.

Within the hfmt.drawsocket abstraction there is a helper script called \textit{startscript.js} which retrieves the user patcher's folder path, and passes the path configuration as an argument to the node.script object start message. 
By default the folder containing the user's patch is used as the root public folder, however, users may wish to choose a different folder. 
For example, by setting the path ``public\_html'', \drawsocket will expect a folder called ``public\_html'' to be located in the same folder as the Max patch running the hfmt.drawsocket abstraction, and if found will use this folder as the public root folder.

In larger projects it is often convenient to sort assets into separate folders for images, sound files, etc. For example if the user wishes to load an image file called ``foo.jpg'' located in a \textit{/public\_html/images} subfolder, they would refer to their file at the address \textit{/images/foo.jpg}.

%%%%%%%% API
\section{Drawsocket API}\label{sec:api}
The \drawsocket API has developed organically as features are gradually added to the system, and has been rewritten several times as new use contexts have arisen.

The API was initially designed in keeping with the conventional ``message'' format used in the Max environment, so that drawing commands could be easily adapted from commands used for other Max drawing objects such as LCD, or jit.gl.sketch.

A Max message is structured as an array, beginning with a selector string, followed by a list of values, which is interpreted by the receiver based on a preexisting schema.
However, as more features were added, some complications arose in regard to the sequence ordering, and as a result an alternative object-oriented API was developed, which makes use of a key-value approach that has proven more extendable for the \drawsocket system (discussed below in section~\ref{sec:objstyle}).

Due to the requirements of the state caching system, it eventually emerged that the user API syntax should be separate from the internal format used to store the prefix states.
As a result, a new script was added to the hfmt.drawsocket abstraction which translates from the user interface API to the lower-level server message syntax.
Therefore the API could also be altered to serve users needs in the future, wrapping the low level API in high level control syntax.

Note that in the discussion below, we use the term \textit{message} as a general purpose term for communication via message events, which could be in different formats (OSC messages, Max messages, JSON objects sent as messages, etc.).


\medskip
\noindent
\textbf{OSC prefix routing.}  
All messages sent from the server, are prefixed by the client's OSC prefix, which is used to route messages to the appropriate clients. 
Multiple clients may be logged into the same URL, in which case they would all receive the same drawing commands. 
For example if you had a group of violins all playing the same part you could have them log into the URL:

\textit{http://server.ip.address:port/violin1}

Then to send messages to the violin 1 section, you would prefix the drawing message with \textit{/violin1}.

To send to all clients, regardless of OSC prefix, \drawsocket provides usage of the OSC \textit{/*} wildcard address.

Note that in OSC, \textit{/*} matches one single address level, whereas the \drawsocket server uses the wildcard address to match any \textit{URL}, which may include multiple slashes.
To avoid confusion with OSC convention, it is strongly recommended to use single level addresses (i.e. use \textit{/violin1}, not \textit{/violin\textbf{/}1} in cases of indexed subgroupings).

\medskip
\noindent
\textbf{Object references.} 
\drawsocket uses the Document Object Model (DOM)\cite{Champion:04:DOM} \textit{id} attribute as the primary mechanism for references individual client objects from the server.
On creation, the client-side script logs a reference to new objects with their unique id, in a set of associative arrays which can be used for fast object lookup by name. 
Through this method, objects may be referred to by name, modified, styled, transformed, or removed.

SVG and HTML nodes use the provided unique identifier as the node's \textit{id} attribute, as per the DOM standard, while other objects such as GSAP animation or Tone.js sound objects are not in the DOM, but logged in the \drawsocket's internal object model.

By using the DOM id attribute, \drawsocket is able to make use of CSS selectors, which opens up other many possibilities for object manipulation and grouping through CSS classes.

\subsection{List-oriented API}\label{sec:maxstyle}
The original ``Max style'' list-oriented  \drawsocket API design used a bundle of individual OSC messages, each of which performed an action on the client system. 
The list-oriented API has now been replaced, however a discussion of this approach is valuable, since it illustrates a structural limitation that we encountered with this formatting approach.

In the list-oriented API, the OSC message's address was used to specify several functional layers at once, concatenated together into one slash separated address: (1) the client OSC prefix, (2) the unique object ID which refers to the object in the client's object lookup system, followed by (3) the command string.
The value of the OSC message was an array of values which wrapped the native SVG or other object models on the client with a simplified set of user accessible parameters. For example the following OSC bundle:

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
    {
         /violin/foo/draw/rect : [100, 100, 25, 25],
         /violin/foo/style/stroke-width : 1
    }
\end{lstlisting}

\noindent
contains two messages prefixed by \textit{/violin} which indicates that the server should send these commands to all clients logged into the \textit{/violin} URL. \footnote{Internally, the server strips off the OSC prefix level from the address, passing on the remaining address levels.} 
Once received on the client system, the script would parse the OSC address, separating the ID from the command string. 
Here, the ID is ``foo'' and the command string is ``draw/rect''.

For each OSC message, the value attached to address was parsed by the client script based on schema defined in the documentation.
In the case of ``draw/rect'', the message's value would be interpreted as defining an SVG rectangle's \textit{x},  \textit{y},  \textit{width}, and \textit{height} values.
The second message works in a similar way, except that rather than creating a new object, it adds an inline SVG/CSS \textit{style} attribute to the object node, setting the \textit{stroke-width} parameter to a value of 1.

\medskip
\noindent
\textbf{Grouping.} 
Things start to get a little more complex with the list-oriented approach when attempting to define SVG group objects and object definitions. 
In these cases child objects can be grouped together and manipulated as a single graphic object, while not requiring each child object to have a unique id.

The first problem we encountered was when trying to include two objects of the same type within the object. 
In the first implementation, a sub-bundle of OSC messages was used to group elements together, however since no ids were required, the following example fails:

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
    /*/groupex/draw/group : {
	/text : [210, 210, ``hi''],
	/text : [310, 210, ``bye'']
    }
\end{lstlisting}

\noindent
It fails because in OSC you are allowed to have multiple messages with the same address, however in Max the OSC messages need to be first converted to Max Dictionary format to be passed to the node.script object, and Max Dictionaries do not allow duplicate addresses.

Another complication arose when trying to style individual objects within a group, since there is no unique identifier to reference for adding inline style tags, and this is not accessible from the list-oriented API syntax. 
To address these two issues, the list-oriented grouping syntax was adapted to use an array of objects (aka sub-bundles in OSC). For example:
 
\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
    /*/groupex/draw/group : [{
	/path : ``M200,200a30,90,0,0,0,0-60a30,30,0,0,0,0,60'',
	/style : ``fill: black''
    }, {
	/text : [210, 210, ``hi''],
	/style : ``fill: red''
    }]
\end{lstlisting}

\noindent
In this case, the \textit{/style} message is bound to the \textit{/path} message by wrapping them together in an object. 
This solution led to a reevaluation of the \drawsocket API syntax, and resulted in the development of the object-oriented based API.

\subsection{Object-oriented API}\label{sec:objstyle}
While the list-oriented approach provides a compact, one-line syntax, this formatting approach also by nature limited, in that the list requires a predefined schema for how the list can be interpreted, and which types of operations the list values may address. 
The list-based approach is thus less easily extendable, since adding a new value to the list requires adding a new step in the interpreting script.
The main benefit of the list syntax is that its compactness makes it sometimes faster for rapid prototyping, however the object-oriented approach can be more easily expanded since the self-describing key-value format allows the receiver to map the input data to a wider set of possibilities.

%The ``object-array'' API uses an array of objects which are processed in a similar way to the ``list-oriented'' API, except that rather than concatenating the sequence of \textit{id}, \textit{command}, and associated generic list of values that need to fit a certain order to be interpreted correctly by the client-side script, the object-oriented approach groups all parameters together in an object and provides separate identifiers for each element. 

For example, whereas above we drew a line with a list like so:
\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  /violin/foo/draw/rect : [100, 100, 25, 25]
\end{lstlisting}

\noindent
The same line could be drawn with the object-based API which uses the \textit{/svg} message, where the \textit{/new} keyword notifies the client that it should create a new SVG element:

\begin{minipage}{\linewidth}
\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  /violin/svg : {
      /new : ``rect'',
      /id : ``foo'',
      /x : 100,
      /y : 100,
      /width : 25,
      /height: 25
  }
\end{lstlisting}
\end{minipage}

\noindent
We can see that in the object-based approach each variable now has a key value, telling us what the variable represents.
The list-approach is a more concise, requiring less typing, however, when we consider further what the messages are representing in the context of the \drawsocket system, the benefit of the object approach becomes clearer.

SVG, an XLM-based format, is designed as tree of \textit{nodes}, each with a set of \textit{attributes} which are defined as key-value pairs.
By using the same attribute names within the \drawsocket object API, the client script can then simply insert as few or many of the attributes as it receives, rather than needing a specific set of attributes, as with the list-based approach.
Also, by staying close to the original SVG API, the user can refer to the SVG specification directly to figure out which attributes they can use, rather than needing to limit their control parameters to those setup in the list parsing schema.\footnote{That said, we have not yet fully tested the entire SVG specification. We believe the object API provides access to everything, but there maybe some unaddressed aspects.} 


For example, extending the above example, we can use the object approach to add a new CSS \textit{class} reference:

\begin{minipage}{\linewidth}
\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  /violin/svg : {
      /new : ``rect'',
      /id : ``foo'',
      /x : 100,
      /y : 100,
      /width : 25,
      /height: 25,
      /class : ``room''
  }
\end{lstlisting}
\end{minipage}

%The \drawsocket object API uses the native SVG attributes by name as per the SVG specification, with the addition of the \textit{/new} keyword.

\medskip
\noindent
\textbf{Keywords.} 
There are currently four reserved keywords used with the \textit{/svg} object array: \textit{/new}, \textit{/style}, \textit{/parent}, and \textit{/child}.

On receiving a \textit{/svg} object (or array of objects), the client-side script iterates each element of the array, and checks if there is an \textit{/id} tag; if so, it selects that element from the DOM lookup table.
Next, the script checks if there is a \textit{/new} message in the object; if so, it creates a new node, either replacing the element at the existing \textit{/id}, or creating a new node if not already existing, and then processes the rest of the object messages.

%This is also convenient, because it means the order of the element is not important.
%Additionally, with the object based method, the script does not make any assumptions about the attributes that the user sets in the SVG node.
%Rather than needing to know the order of elements in a list designed by the script author, the user can refer to the official SVG specification, and make use of a larger set of possible attributes and operations
Elements may also be partially updated by this method, for example if after sending the above object array, creating the objects ``foo'' and ``bar'', sending the message:

\begin{minipage}{\linewidth}
\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  /violin/svg : {
      /id : ``foo'',
      /width : 100
  }
  \end{lstlisting}
\end{minipage}

\noindent
will set only the \textit{/width} attribute of the node ``foo''.

\subsection{Parent and Child Elements}\label{sec:parent}
Appending child nodes to parent SVG element can be accomplished via the \textit{/parent} and \textit{/child} keywords.

The \textit{/child} keyword, is a high-level API that allows the user to specify one or more child nodes in a tree syntax.
The value attached to this address will be inserted as a child of the parent node, for example the inner text of a \textless text\textgreater element, or a new node within a \textless g\textgreater the SVG grouping element tag.

Here is an example of a circle and line contained in new SVG group, called ``noteline'':

% osc data formating
\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
   /violin/svg : {
        /new : ``g'',
        /id : ``noteline'',
        /x : 100,
        /y : 100,
        /child : [{
      	    /new : ``line'',
            /id : ``liney'',
      	    /x1 : 10,
      	    /y1 : 5,
      	    /x2 : 100,
      	    /y2 : 5,
      	    /style : {
      	        /stroke-width : 1
      	    }
      	}, {
      	    /new : ``circle'',
            /id : ``circley'',
      	    /cx : 5,
      	    /cy : 5,
      	    /r : 5,
      	    /style : {
      	        /stroke-width : 2,
      		/fill : ``none'',
      		/stroke : ``black''
      	    }
        }]
    }
\end{lstlisting}

The tree syntax is supported as part of the high-level API, however internally, the API translation script flattens the tree into an array of nodes. 
If an \textit{/id} value is found, the node is considered to be a top-level element which can be updated by reference to its unique name, if no \textit{/id} is found the node is consider a dependent of the parent node and is not updatable in the server cache system.
The API syntax reformatting script internally moves child nodes with \textit{/id} values, to its main array of SVG element, and inserts a \textit{/parent} reference attribute.

Nodes with a \textit{/parent} attribute are inserted as children of the node with the \textit{/id} specified by the \textit{/parent}, as long as the parent element is already existing in the DOM.
If no \textit{/parent} element is specified, the node is inserted into the default SVG group ``main-svg''.

\begin{minipage}{\linewidth}
For example, the above tree syntax could also be written this way:

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
   /violin/svg : [{
        /new : ``g'',
        /id : ``noteline'',
        /x : 100,
        /y : 100
   }, {
        /new : ``line'',
        /id : ``liney'',
        /parent : ``noteline'',
        /x1 : 10,
        /y1 : 5,
        /x2 : 100,
        /y2 : 5,
        /style : {
            /stroke-width : 1
      	}
   }, {
        /new : ``circle'',
        /id : ``circley'',
        /parent : ``noteline'',
        /cx : 5,
        /cy : 5,
        /r : 5,
        /style : {
            /stroke-width : 2,
            /fill : ``none'',
            /stroke : ``black''
        }
    }]
\end{lstlisting}
\end{minipage}


\subsection{SVG layer drawing contexts}\label{sec:contexts}
In an SVG file, each object element is drawn in the same order as they are written in the file, from top to bottom, with the last element being drawn last, and therefore on the top layer.
In the \drawsocket system, the drawing order is set via the node creation (using the \textit{/new} keyword).

Using the \textit{/parent} and \textit{/child} keywords, new nodes can be created and inserted as children of existing nodes.
The order in which the child nodes are created, sets the drawing order of the nodes.
However, \textit{editing} nodes (i.e. setting values without the use of the \textit{/new} keyword), does \textit{not} change the drawing order.
Similarly, inserting nodes does not change the drawing order of the parent nodes.
This rule makes it possible to use SVG groups as drawing layer contexts, which maintain stacking order relative to each other.
The high-level API also provides a tree model utility keyword called \textit{/appendTo}, which assists in assigning one or more nodes to a parent node.

As an illustration, let's say you would like to have three layers, a background, middle and overlay. 
You could create three new groups within the main SVG node, called ``back'', ``main'', and ``overlay'', in a specific drawing order, like this:

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
   /violin/svg : [{
       /new : ``g'',
       /id : ``back''
   }, {
       /new : ``g'',
       /id : ``main''
   } , {
       /new : ``g'',
       /id : ``overlay''
   }]
\end{lstlisting}

You could then use the  \textit{/appendTo} high-level keyword to append nodes to the groups like this:

\begin{minipage}{\linewidth}
\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  /*/svg : {
      /appendTo : {
        /main : {
            /id : "clef",
            /new : "text",
            /child : "&#xE050",
            /class : "bravura_text",
            /x : 40,
            /y : 50
        },
        /back : {
            /new : "rect",
            /id : "rect",
            /x : 5,
            /y : 5,
            /width : 100,
            /height : 100,
            /fill : "red"
        },
        /overlay : {
            /new : "circle",
            /id : "circle",
            /cx : 50,
            /cy : 50,
            /r : 10,
            /fill : "blue"
        }
     }
  } 
\end{lstlisting}
\end{minipage}

As with the above discussion of the \textit{/child} keyword, the API translation script will convert the parent nodes specified with the \textit{/appendTo} tag as \textit{/parent} values.

Using this approach, multiple layers of SVG elements can be grouped together and manipulated (with some limitations as described in the SVG specification).

\subsection{SVG CSS Styling.} 
The ability to dynamically apply CSS styling operations on SVG elements provides the user with an extremely flexible mechanism for composing, and animating graphic layout.
This functionality comes ``for free'' since it is used ubiquitously for web-design across the internet.

For most common \drawsocket usages, a set of default layout properties are defined in the file \textit{drawsocket-default.css}, which is loaded with the default HTML file (\textit{drawsocket-page.html}).

The linked stylesheet sets some defaults for SVG element types, for example \textit{lines} have a default stroke width value so that they are visible by default.

\drawsocket also provides dynamic access to CSS settings, for which it is useful to understand the hierarchy of SVG style properties. 

There are three levels of inheritance with SVG CSS styling: 

(1) \textit{presentation attributes}, set within the element, e.g.:

\textit{\textless rect~fill=``red''~\textgreater}; 

(2) \textit{stylesheet} definitions, set in an attached CSS stylesheet, or within an \textless style\textgreater element;
and

(3) \textit{inline styling}, a snippet of CSS wrapped in a string and set in an elements's \textit{style} attribute, e.g.:

\textit{\textless rect~style=``fill:~red;~stroke:~2''~\textgreater}.

Each is overridden by the next: stylesheets override presentation attributes, and inline styles override all the others.\footnote{With one exception, stylesheet definitions with the \textit{!important} tag will override inline styles.} 

Using CSS \textit{class} selector syntax opens up many possibilities.
For example, here is an example using the object-array syntax to set create two CSS classes: (1) ``.notehead'' which sets defaults for fill and stroke propertys, as well as the radius value, \textit{/r} ; and (2) ``.notehead.open'', a sub-class of ``.notehead'' which overrides the fill property. 

Following the \textit{/css} definitions, a new SVG circle object is created and configured with the ``notehead open'' class.

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  /violin/css : [ {
      /selector : ".notehead",
      /props : {
          /stroke : "black",
	  /stroke-width : 2,
	  /fill : "black",
          /r : 5
      }
  }, {
      /selector : ".notehead.open",
      /props : {
          /fill : "none"
      }
  }],
  /violin/svg : {
      /new : ``circle'',
      /id : ``foo'',
      /class : ``notehead open'',
      /cx : 20,
      /cy : 20
  }
 \end{lstlisting}


\subsection{SVG import and library definitions}\label{sec:defs}
\drawsocket provides access to several methods for importing and reusing fragments of SVG.
This is a useful approach for reducing the amount of data that needs to be sent over the network, and can greatly simplify the construction of more complex notation situations.

\medskip
\noindent
\textbf{Referencing SVG definitions.} 
There are two node types in the SVG specification which allow the user to create prototypes of graphic elements, \textit{defs} and \textit{symbol}, which can be applied like a stamp via the \textit{use} tag. 

Within the \drawsocket main SVG element there is element group called \textit{defs} which is not directly drawn to the screen, but is visible by using the browser's HTML element viewer tool.
\drawsocket uses the same drawing context syntax for the \textit{defs} node, as it does for the other drawing layers.

For example, the following snippet makes a new SVG group object in the \textit{defs}, called ``noteline'', which contains a line and a circle:

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  /violin/svg : {
      /def : {
          /new : ``g'',
          /id : ``noteline'',
          /child : [{
              /new : ``line'',
              /x1 : 10,
              /y1 : 10,
              /x2 : 100,
              /y2 : 10
         }, {
            /new : ``circle',
            /cx : 5,
            /cy : 5,
            /r : 5
        }]
    } 
  }
 \end{lstlisting}

Typically the user would send a library of definitions at the beginning of the piece, and then refer to the set of definitions as needed via the the \textit{use} SVG element and its \textit{href} attribute, which references a definition by its \textit{id} attribute.\footnote{Note that for all selections we are using the HTML/CSS \textit{\#} sign to specify that the following string is an \textit{id}.}

For example, the following new SVG object ``foo'', references the ``noteline'' definition above, offset to ${x,y}$ position $\{100,100\}$:

\begin{minipage}{\linewidth}
\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  /violin/svg : {
      /new : ``use'',
      /id : ``foo'',
      /href : ``#noteline'',
      /x : 100,
      /y : 100
   }
 \end{lstlisting}
\end{minipage}

\medskip
\noindent
\textbf{Importing fragments.} 
The \textit{use}-\textit{href} syntax approach can also be used to import elements from external SVG files stored in the public HTML folder, by adding the target object's \textit{id} to the external file path.
For example, to reference an object with the id ``boo'' in an external file called ``other.svg'' that is located in the public subfolder called ``media'' you could use the following snippet:

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  /violin/svg : {
      /new : ``use'',
      /id : ``foo'',
      /href : ``/media/other.svg#boo''
  }
 \end{lstlisting}

If \textit{x} or \textit{y} attributes are set in the \textit{use} node, the referenced object will be offset by the amount specified by the  \textit{use} attributes.

\drawsocket also provides an additional option with the \textit{href} attribute. If the \textit{href} value is a list, the second value is non-zero, the script will find the original object's bounding box and offset so that it lies at the origin $\{0,0\}$, and then applies the ${x,y}$ values as a second operation. The benefit of this feature is that it allows you to coordinate positions of objects without needing to know their original position in the reference file.

\subsection{PDF import}\label{sec:pdf}
PDF files may be imported into \drawsocket.
For example, to load a PDF, storing it at the \drawsocket id ``foo'', setting it's \textit{x} position, \textit{width} and then set it to page 2:

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  /*/pdf : {
      /id : "newpdf",
      /href : "/media/flint_piccolo_excerpt.pdf",
      /width : 600,
      /x : 100,
      /page : 2
  }
 \end{lstlisting}


\subsection{Animation}\label{sec:animation}
While \drawsocket objects may be animated using native CSS transitions and keyframes, the GSAP TweenMax and TimlineMax libraries were introduced to provide a much more convenient and cross-browser supported method.
With the TweenMax library users can create a ``tween'' transition between the object's current position and current CSS property values, to another set of values over a given amount of time, using the TweenMax.to function via the \textit{/tween} \drawsocket command. For example:
\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]

    /violin/tween : {
        /id : ``aaa'',
        /target : ``#note'', 
        /dur : 10,
        /vars : {
            /x : 100,
            /y : 100,
            /opacity : 0
        }
    }
 \end{lstlisting}
\noindent
moves the SVG object ``note'' to the ${x,y}$ positions $\{100,100\}$, and fades the opacity to zero over a course of 10 seconds.
The \textit{tween} is stored as object in the \drawsocket script at the given id (here ``aaa''), and may be recalled at will (see the online documentation for more details).
The CSS selector \textit{/target}, \textit{/dur} and \textit{/vars} are plugged directly into the argument fields for the TweenMax.to function.\footnote{https://greensock.com/docs/TweenMax/TweenMax()}

More complex animations can be implemented with the TimelineMax function, via the \drawsocket \textit{/timeline} command, which is comprised of an array of tweens (which can also have different targets).
As with the TweenMax.to function, an effort was made to make the encoding syntax as close to the native GSAP Timeline function as possible so users can refer to the GSAP documentation for full reference.

\begin{minipage}{\linewidth}
\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
  /violin/timeline : {
      /id : ``foo_line'',
      /init : {
          /paused : "true",
          /yoyo : "true",
          /repeat : 20
      },
      /tweens : [{
	  /target : "#bar",
	  /dur : 1,
	  /vars : {
	      /y : 270,
	      /x : 100,
	      /scaleX : "200%",
	      /opacity : 1,
	      /ease : "linear"
	  }
      }, {
	  /target : "#bar",
	  /dur : 2,
	  /vars : {
	       /y : 10,
	       /x : 0,
	       /scale : "100%",
	       /opacity : 1,
	       /ease : "linear"
      	  }
      }]
  }
\end{lstlisting}
\end{minipage}

\drawsocket provides the \textit{/cmd} keyword for tweens (and timelines of tweens) to start, stop, reset, reverse, etc.

\medskip
\noindent
\textbf{Synchronization.} 
All commands sent from the server are timestamped, which provides \drawsocket with a mechanism to synchronize animations.
Using the timesync.js library, the client periodically asks the server for its current clock time and logs an offset value between the two clocks.
Then, whenever a new animation start request is received, the client checks the message's timestamp relative to the current client clock time minus the logged difference from the server time to get the corrected animation start time in terms of the server clock.
The client then checks the duration of the animation (tween or timeline) to make sure it hasn't already missed the end time for the animation, if not, the client script starts the animation, fast-forwarding if necessary to compensate for network lag.

\subsection{Sound}\label{sec:sound}
In addition to providing access to browser-based drawing tools, \drawsocket also makes use of the Tone.js~\cite{mann2015interactive} WebAudio\footnote{https://www.w3.org/TR/webaudio/} Framework for browser-based sound production.
Currently \drawsocket supports only loading and playing sound files, but in the future we may add other features from Tone.js as well.

For example, to load an mp3 file and start looping playback:

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
/*/sound : {
    /new : "Player",
    /id : "kick",
    /vars : {
        /url : "/media/808_mp3/kick1.mp3",
        /autostart : "true",
        /loop : "true"
    }
}
\end{lstlisting}


\subsection{HTML5}\label{sec:html}
\drawsocket provides access to HTML nodes via the \textit{/html} tag. 

For example, this loads a video:

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
/*/html : {
    /new : "video",
    /id : "foo",
    /child : {
        /new : "source",
        /type : "video/mp4",
        /src : "somerandommovie.mp4"
    }
}
\end{lstlisting}

HTML5 JS object methods can be called via the \textit{/call} keyword.\footnote{\textit{/tone} objects also support the \textit{/call} keyword.}
For example, this starts playing the above video:

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
/*/html : {
    /id : "foo",
    /call : {
        /play : ""
    }
}
\end{lstlisting}

%\medskip
%Note that there is some time required to load the file, so the client will fail to play the file if it hasn't finished loading it yet. At the moment there is no notification for when the file has finished loading, but this could be added easily.
%Note also that to start the browser audio, users must first click or touch the screen if using a tablet.

\subsection{User Interaction}\label{sec:interaction}
Lastly, \drawsocket also sends user interaction information back to the server, outputting the data into Max where it can be used to control other processes, through mouse and multi-touch event listeners, and via HTML textfield input forms.
When the user's mouse or fingers move over the screen \drawsocket reports the $x,y$ position and the top-most graphic object under the fingers or cursor, and bound with the OSC prefix.\footnote{Currently there is no unique client identifier, all users on the same URL will send their user interaction data via the same OSC prefix. A unique tagging system will likely be implemented at some point.}

\drawsocket also provides access to HTML text input fields. To create a text field, users first create a form with a default text prompt and then position the form by applying a CSS transform, or tween. When a client enters text into the text input field and hits enter or clicks outside of the form, the text is sent back to the server and output in Max in a similar fashion to mouse and multi-touch data.

\medskip
\noindent
\textbf{User defined event callbacks.}
\drawsocket's \textit{processCmdObj} function can also be invoked from a callback function, to create interactive actions. For example, the following snippet, which creates an SVG path object, and assigns an \textit{onclick} callback function which triggers a sample playback when the client user clicks on the path object:

\begin{lstlisting}[ mathescape,columns=fullflexible,basicstyle=\oscfontsize\fontfamily{lmvtt}\selectfont ]
/*/svg : {
    /new : "path",
    /id : "wow",
    /style : {
        /fill : "red"
    },
    /d : "M100,100a30,30,0,0,0,0-60a30,30,0,0,0,0,60",
    /onclick : "processCmdObj({
        key: 'sound',
        val: {
            id: 'kick',
            call: { 
                restart: '' 
            }
        }
    })"
}
\end{lstlisting}

% Georg's files
\input{maxscore-taiwan}


\section{Future Work}

\drawsocket currently still considered ``in development'', that said, the system has already been used in several live performances, and appears to be fairly robust.
As we prepare for the large-scale extension of the system to the St. Pauli Elbtunnel we will have a good opportunity to fully stress-test the system.

One potential issue that we imagine could arise is with the caching system. 
Currently the caching routine is processed within the callback function that gets called when a new dictionary arrives from Max.
On receiving a new dictionary, the server routes the data, sending packets to the appropriate clients, and then sends the packets to the cache system which unions the data with any nodes with a matching \textit{id} (or \textit{selector} in the case of CSS).
There is a question about the scalability of this approach. 

Node.js, like vanilla JS, uses an ``event driven'', ``single threaded event loop model'', which uses a queue of event callbacks which need to be processed asynchronously.
However, it is possible to block the event loop\cite{node-eventloop} within a callback function, should the execution take too long.
In particular, the JSON.parse and JSON.stringify operations are potentially expensive, with a complexity of $O(n)$; so, depending on the size of the incoming dictionary, this could significantly slow down the response of the server.
In our testing so far, we have already noticed some issues with processing very large dictionaries arriving from Max, but we need to investigate further.
It is possible that since the data is broadcasted before being sent to the caching system, that the blocking of the event loop will be less noticeable on the client-side, however, the responsiveness of the server will be reduced and this will likely effect the clock-synchronization routine, and could also in extreme cases result in a buildup of events to process in queue.
To address this issue, we might look into storing the prefix states in a separate database, which runs as a separate process.


\begin{acknowledgments}
The authors would like to thank Jacob Sello for and James Cheung for their detailed testing the system which pushed the development of many new features and design considerations. We would also like to acknowledge the Federal Ministry of Education and Research in Germany (BMBF), for their support of this research through the Innovative Hochschule: Stage\_2.0 initiative.
\end{acknowledgments} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%bibliography here
\balance
\bibliography{symbolist}
\end{document}




